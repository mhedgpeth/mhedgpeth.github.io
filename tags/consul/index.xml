<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>consul on Michael Hedgpeth</title><link>https://hedge-ops.com/tags/consul/</link><description>Recent content in consul on Michael Hedgpeth</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>MIT</copyright><lastBuildDate>Fri, 22 Apr 2016 08:00:44 +0000</lastBuildDate><atom:link href="https://hedge-ops.com/tags/consul/index.xml" rel="self" type="application/rss+xml"/><item><title>Orchestration Maturity Model with Chef</title><link>https://hedge-ops.com/orchestration-maturity-model-with-chef/</link><pubDate>Fri, 22 Apr 2016 08:00:44 +0000</pubDate><guid>https://hedge-ops.com/orchestration-maturity-model-with-chef/</guid><description>&lt;div class="full-width">
&lt;img src="https://hedge-ops.com/images/feature-orchestration-maturity-model-with-chef.jpg" alt="Orchestration with Chef" />
&lt;/div>
&lt;p>One of our &lt;a href="https://hedge-ops.com/proof-of-concept/">earliest questions&lt;/a> about configuration management tools is how we would do orchestration with them. We realized early on that with chef the orchestration story was fairly weak, especially compared with something like &lt;a href="http://saltstack.com/">salt&lt;/a>. But chef&amp;rsquo;s &lt;a href="http://hedge-ops.com/technology-partnership/">other benefits&lt;/a> outweighed the weaknesses so we moved forward.&lt;/p>
&lt;p>The whole time though I was confused about why Chef hadn&amp;rsquo;t invested more in orchestration. Salt and Ansible has it as a first class citizen and Puppet was &lt;a href="https://docs.puppet.com/pe/latest/app_orchestration_overview.html">actively adding it to its product&lt;/a>. I didn&amp;rsquo;t really &amp;ldquo;get&amp;rdquo; it until I listened to Julian Dunn&amp;rsquo;s &lt;a href="https://www.youtube.com/watch?v=kfF9IATUask">excellent presentation&lt;/a> on it at Ghent.&lt;/p>
&lt;p>Chef, as a company, is more interested in giving you what will work for you than giving you what you&amp;rsquo;re asking for. This is what makes them such a special partner for us. They&amp;rsquo;re more of a coach and less of an enabler. This has led me to think of orchestration as a maturity journey through three phases:&lt;/p>
&lt;h2 id="phase-1-do-it-like-before">&lt;strong>Phase 1: Do it Like Before!&lt;/strong>&lt;/h2>
&lt;p>The first phase of orchestration will be to model how you have been doing things before. OK, I need to stop services, copy files, start services. That&amp;rsquo;s orchestration, right?&lt;/p>
&lt;p>At a surface level this is fine, but it leaves out the edge cases that happen when you&amp;rsquo;re dealing with a scaled infrastructure:&lt;/p>
&lt;ul>
&lt;li>What happens when a node was down and didn&amp;rsquo;t get the message to stop, and then comes back up in the middle of your upgrade, and starts?&lt;/li>
&lt;li>What happens when a new node is added at a time when  you&amp;rsquo;re not doing an upgrade? Are any of those orchestration commands critical to the node itself?&lt;/li>
&lt;li>Are you splitting configuration management between your configuration management tool &lt;em>and&lt;/em> your orchestration? If you are directly stopping a service, THEN running chef later, then your configuration management is leaking out of your system and into other places.&lt;/li>
&lt;/ul>
&lt;h2 id="phase-2-declaratively-manage-state">&lt;strong>Phase 2: Declaratively Manage State&lt;/strong>&lt;/h2>
&lt;p>If we&amp;rsquo;re writing chef recipes and starting from the beginning with some infrastructure, why live with the limitations of Phase 1? Why don&amp;rsquo;t we solve this problem? Thankfully with a tool like &lt;a href="https://www.consul.io/">consul&lt;/a> we can solve the problem by making some subtle changes:&lt;/p>
&lt;ul>
&lt;li>Create a real-time shared data view of the state of your system (with consul, &lt;a href="https://zookeeper.apache.org/">zookeeper&lt;/a>)&lt;/li>
&lt;li>Using this shared data view, define &lt;em>all&lt;/em> desired states of the system. So if you need to transition your web cluster from the states of: off, waiting, converged, set that in your key value store&lt;/li>
&lt;li>Write your chef recipe to define the desired state (resources) that are compiled &lt;em>based on the desired state defined in the shared data view&lt;/em>. So you have an if statement that says &amp;ldquo;if we want this thing to be off right now, there is a service resource with action of ‘off&amp;rsquo;&amp;rdquo;&lt;/li>
&lt;li>Write an orchestrator that manages the state transitions between nodes in the environment &lt;em>by updating the shared data view&lt;/em>.  With consul we can do a consul_exec on our nodes to force chef to run. Or take it even further. And the orchestrator itself can be written through chef.&lt;/li>
&lt;/ul>
&lt;p>This gives you a number of benefits over the earlier phase:&lt;/p>
&lt;ul>
&lt;li>If a node isn&amp;rsquo;t there when the state changes, it checks in and converges to the correct state, immediately! You &lt;em>always&lt;/em> get the node at the right state in the process because they are sharing the latest up to date shared data view&lt;/li>
&lt;li>If a node is added, it will also converge to the correct state. It checks in and catches up immediately. Now you don&amp;rsquo;t have to worry about adding nodes and coordinating that with upgrades; things will just happen.&lt;/li>
&lt;li>All configuration management are belong to chef. Simple.&lt;/li>
&lt;/ul>
&lt;h2 id="phase-3-decouple-the-nodes">&lt;strong>Phase 3: Decouple the Nodes&lt;/strong>&lt;/h2>
&lt;p>The unfortunate reality though, is that even after phase 2 you may not be ready for bursting and scale. In order for those capabilities to exist, you need to have services that are independent of each other. So it shouldn&amp;rsquo;t matter that your web tier is on a particular version and the database hasn&amp;rsquo;t caught up yet. The web tier should tolerate that reality. So you can then update them separately and not worry about it.&lt;/p>
&lt;p>I still think there is a role for real-time orchestration to happen in order to manage the portions of your infrastructure to go through a little at a time until all is upgraded. But the complexities of having to turn one layer off so another layer can do its thing should largely go away.&lt;/p>
&lt;p>Unfortunately this is really up to the software design itself to facilitate. Therefore, it&amp;rsquo;s really a business decision on whether that infrastructure should be made burstable and thus truly cloud-enabled. In some cases, we&amp;rsquo;ll only get as far as phase 2. In others we&amp;rsquo;ll go all the way, but probably camp out at phase 2 while the software catches up. That&amp;rsquo;s the way it should be: let&amp;rsquo;s get there little by little. As long as we&amp;rsquo;re going in the right direction, we&amp;rsquo;re good.&lt;/p></description></item></channel></rss>